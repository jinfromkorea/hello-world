<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>GetScreen</title>
</head>
<body>
  <button id="join-room1">Get 'Screan1'</button>
  <button id="join-room2">Get 'Screan2'</button>
  <div id="screen-container">
    <video id="screen1"></video>
    <video id="screen2"></video>
  </div>
  <script src="https://rtcmulticonnection.herokuapp.com/dist/RTCMultiConnection.js"></script>
  <script src="https://rtcmulticonnection.herokuapp.com/socket.io/socket.io.js"></script>
  <script>
/* 
 * RTCMultiConnection 생성자에는 2개 인자가 가능함. 
 * 첫번째는 roomid 임.
 *          connection.channel = connection.sessionid = roomid
 * 두번째는 forceOptions임. useDefaultDevices, autoOpenOrJoin
 */    
var videoPreview = document.getElementById('screen1');
var broadcastId = 'Screen1';
var connection = new RTCMultiConnection( null, {useDefaultDevices: true});
connection.enableScalableBroadcast = true;
connection.maxRelayLimitPerUser = 1;
connection.autoCloseEntireSession = true;
connection.socketURL = 'https://rtcmulticonnection.herokuapp.com:443/';
connection.socketMessageEvent = 'scalable-screen-broadcast-demo';
connection.session = { screen: true, oneway: true };
connection.videosContainer = document.getElementById('screen-container');
connection.dontCaptureUserMedia = true;
connection.connectSocket( _callback_connectSocket );

function _callback_connectSocket(socket){
    console.log('[share]', 'RTCMultiConnection 준비함.[connectSocket()]', socket);
    /*
     * document.getElementById('join-room1').onclick 부분을 볼것.
     * socket.emit('join-broadcast', ..) 으로 Scalable-Broadcast.js 부분의 로직 보면됨.
     */
    socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
        console.log('[share]', 'join-broadcaster', hintsToJoinBroadcast);
        connection.sdpConstraints.mandatory = { OfferToReceiveVideo: true, OfferToReceiveAudio: false };
        /*
         * RTCMultiConnection.js 을 보면.. 
         * connection.join = function(remoteUserId, options){..}
         */
        connection.join(hintsToJoinBroadcast.userid);
    });
    socket.on('logs', function(log) {
        console.log('[share]', log);
    });
    socket.on('rejoin-broadcast', function(broadcastId) {
        console.log('[share]', 'rejoin-broadcast', broadcastId);
        connection.attachStreams = [];
        socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
            console.log('[share]', 'check-broadcast-presence', broadcastId, isBroadcastExists, connection.userid);
            if(!isBroadcastExists) {
                // the first person (i.e. real-broadcaster) MUST set his user-id
                connection.userid = broadcastId;
            }
            socket.emit('join-broadcast', { broadcastId: broadcastId, userid: connection.userid, typeOfStreams: connection.session });
        });
    });
    socket.on('broadcast-stopped', function(broadcastId) {
        console.log('[share]', 'broadcast-stopped', broadcastId);
        console.error('broadcast-stopped', broadcastId);
        alert('This broadcast has been stopped.');
    });
    socket.on('start-broadcasting', function(typeOfStreams) {
        console.log('[share]', 'start-broadcasting', '찍힐리가 없음');
    });
}
connection.onstream = function(event){
    console.log('[share]', 'onstream', event);
    console.log('[share]', 'onstream', connection.isInitiator, event.type, event.mediaElement); // 항상 false,remote

    videoPreview.srcObject = event.stream;
    videoPreview.play();
    videoPreview.userid = event.userid;
    connection.isUpperUserLeft = false;
    connection.attachStreams = [event.stream];
    connection.sdpConstraints.mandatory = { OfferToReceiveVideo: false, OfferToReceiveAudio: false };
    connection.getSocket().emit('can-relay-broadcast');

    console.log('[share]', 'onstream', connection.DetectRTC.browser.name, connection.getAllParticipants());
    if(connection.DetectRTC.browser.name === 'Chrome') {
        connection.getAllParticipants().forEach(function(p) {
            console.log('[share]', 'onstream', p, event.userid);
            if(p + '' != event.userid + '') {
                var peer = connection.peers[p].peer;
                console.log('[share]', 'onstream', peer.getLocalStreams());
                console.log('[share]', 'onstream', event.stream.stream);
                peer.getLocalStreams().getTracks().forEach( track => track.stop() );
                event.stream.stream.getTracks().forEach( track => peer.addTrack(track, event.stream.stream) )

                connection.dontAttachStream = true;
                connection.renegotiate(p);
                connection.dontAttachStream = false;
            }
        });
    }

    if(connection.DetectRTC.browser.name === 'Firefox') {
        // Firefox is NOT supporting removeStream method
        // that's why using alternative hack.
        // NOTE: Firefox seems unable to replace-tracks of the remote-media-stream
        // need to ask all deeper nodes to rejoin
        connection.getAllParticipants().forEach(function(p) {
            if(p + '' != event.userid + '') {
                connection.replaceTrack(event.stream, p);
            }
        });
    }
};
connection.onstreamended = function(event){ 
    console.log('[s1]', 'onstreamended', event); 
    console.log('[s1]', 'onstreamended', connection.attachStreams);
    //connection.getSocket().emit('disconnect');
    //connection.attachStreams.pop();
    //connection.closeEntireSession();
};
var allRecordedBlobs = [];
connection.onleave = function(event){
    console.log('[share]', 'onleave', event);
    console.log('[share]', 'onleave', event.userid, videoPreview.userid);
    if(event.userid !== videoPreview.userid) return;
    //connection.connectSocket(_callback_connectSocket);

    connection.getSocket().emit('can-not-relay-broadcast');
    connection.isUpperUserLeft = true;
    console.log('[share]', 'onleave', allRecordedBlobs.length, connection.currentRecorder);
    if(allRecordedBlobs.length) {
        // playing lats recorded blob
        var lastBlob = allRecordedBlobs[allRecordedBlobs.length - 1];
        videoPreview.src = URL.createObjectURL(lastBlob);
        videoPreview.play();
        allRecordedBlobs = [];
    } else if(connection.currentRecorder) {
        var recorder = connection.currentRecorder;
        connection.currentRecorder = null;
        recorder.stopRecording(function() {
            if(!connection.isUpperUserLeft) return;

            videoPreview.src = URL.createObjectURL(recorder.blob);
            videoPreview.play();
        });
    }
    if(connection.currentRecorder) {
        connection.currentRecorder.stopRecording();
        connection.currentRecorder = null;
    }
};

document.getElementById('join-room1').onclick = function(event){
    console.log('[share]', event);
    /*
     * Scalable-Broadcast.js 을 같이 볼것. 
     * socket.on('check-broadcast-presence', function(userid, callback){..})
     */
    connection.getSocket().emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
        console.log('[share]', 'check-broadcast-presence', broadcastId, isBroadcastExists, connection.userid);
        if( isBroadcastExists ){
            /*
             * Scalable-Broadcast.js 을 같이 볼것.
             * socket.on('join-broadcast', function(user){..});
             */
            connection.getSocket().emit('join-broadcast', { broadcastId:broadcastId, userid:connection.userid, typeOfStreams:connection.session });
        }else{
            alert('상대방의 스크린이 준비되지 않았습니다.');
        }
    });
};

localStorage.setItem(connection.socketMessageEvent, 'get-screen');
  </script>
</body>
</html>